.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "CRYPTO" "" "April 2012" "" ""
.
.nf

Stability: 3 \- Stable
.
.fi
.
.P
Use \fBrequire(\'crypto\')\fR to access this module\.
.
.P
The crypto module requires OpenSSL to be available on the underlying platform\. It offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection\.
.
.P
It also offers a set of wrappers for OpenSSL\'s hash, hmac, cipher, decipher, sign and verify methods\.
.
.SH "crypto\.createCredentials(details)"
Creates a credentials object, with the optional details being a dictionary with keys:
.
.IP "\(bu" 4
\fBkey\fR : a string holding the PEM encoded private key
.
.IP "\(bu" 4
\fBcert\fR : a string holding the PEM encoded certificate
.
.IP "\(bu" 4
\fBca\fR : either a string or list of strings of PEM encoded CA certificates to trust\.
.
.IP "\(bu" 4
\fBciphers\fR: a string describing the ciphers to use or exclude\. Consult \fIhttp://www\.openssl\.org/docs/apps/ciphers\.html#CIPHER_LIST_FORMAT\fR for details on the format\.
.
.IP "" 0
.
.P
If no \'ca\' details are given, then node\.js will use the default publicly trusted list of CAs as given in \fIhttp://mxr\.mozilla\.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata\.txt\fR\.
.
.SH "crypto\.createHash(algorithm)"
Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests\.
.
.P
\fBalgorithm\fR is dependent on the available algorithms supported by the version of OpenSSL on the platform\. Examples are \fB\'sha1\'\fR, \fB\'md5\'\fR, \fB\'sha256\'\fR, \fB\'sha512\'\fR, etc\. On recent releases, \fBopenssl list\-message\-digest\-algorithms\fR will display the available digest algorithms\.
.
.P
Example: this program that takes the sha1 sum of a file
.
.IP "" 4
.
.nf

var filename = process\.argv[2];
var crypto = require(\'crypto\');
var fs = require(\'fs\');

var shasum = crypto\.createHash(\'sha1\');

var s = fs\.ReadStream(filename);
s\.on(\'data\', function(d) {
  shasum\.update(d);
});

s\.on(\'end\', function() {
  var d = shasum\.digest(\'hex\');
  console\.log(d + \'  \' + filename);
});
.
.fi
.
.IP "" 0
.
.SH "Class: Hash"
The class for creating hash digests of data\.
.
.P
Returned by \fBcrypto\.createHash\fR\.
.
.SS "hash\.update(data, [input_encoding])"
Updates the hash content with the given \fBdata\fR, the encoding of which is given in \fBinput_encoding\fR and can be \fB\'utf8\'\fR, \fB\'ascii\'\fR or \fB\'binary\'\fR\. Defaults to \fB\'binary\'\fR\. This can be called many times with new data as it is streamed\.
.
.SS "hash\.digest([encoding])"
Calculates the digest of all of the passed data to be hashed\. The \fBencoding\fR can be \fB\'hex\'\fR, \fB\'binary\'\fR or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Note: \fBhash\fR object can not be used after \fBdigest()\fR method been called\.
.
.SH "crypto\.createHmac(algorithm, key)"
Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key\.
.
.P
\fBalgorithm\fR is dependent on the available algorithms supported by OpenSSL \- see createHash above\. \fBkey\fR is the hmac key to be used\.
.
.SH "Class: Hmac"
Class for creating cryptographic hmac content\.
.
.P
Returned by \fBcrypto\.createHmac\fR\.
.
.SS "hmac\.update(data)"
Update the hmac content with the given \fBdata\fR\. This can be called many times with new data as it is streamed\.
.
.SS "hmac\.digest([encoding])"
Calculates the digest of all of the passed data to the hmac\. The \fBencoding\fR can be \fB\'hex\'\fR, \fB\'binary\'\fR or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Note: \fBhmac\fR object can not be used after \fBdigest()\fR method been called\.
.
.SH "crypto\.createCipher(algorithm, password)"
Creates and returns a cipher object, with the given algorithm and password\.
.
.P
\fBalgorithm\fR is dependent on OpenSSL, examples are \fB\'aes192\'\fR, etc\. On recent releases, \fBopenssl list\-cipher\-algorithms\fR will display the available cipher algorithms\. \fBpassword\fR is used to derive key and IV, which must be \fB\'binary\'\fR encoded string (See the Buffer section \fIbuffer\.html\fR for more information)\.
.
.SH "crypto\.createCipheriv(algorithm, key, iv)"
Creates and returns a cipher object, with the given algorithm, key and iv\.
.
.P
\fBalgorithm\fR is the same as the \fBcreateCipher()\fR\. \fBkey\fR is a raw key used in algorithm\. \fBiv\fR is an Initialization vector\. \fBkey\fR and \fBiv\fR must be \fB\'binary\'\fR encoded string (See the Buffer section \fIbuffer\.html\fR for more information)\.
.
.SH "Class: Cipher"
Class for encrypting data\.
.
.P
Returned by \fBcrypto\.createCipher\fR and \fBcrypto\.createCipheriv\fR\.
.
.SS "cipher\.update(data, [input_encoding], [output_encoding])"
Updates the cipher with \fBdata\fR, the encoding of which is given in \fBinput_encoding\fR and can be \fB\'utf8\'\fR, \fB\'ascii\'\fR or \fB\'binary\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
The \fBoutput_encoding\fR specifies the output format of the enciphered data, and can be \fB\'binary\'\fR, \fB\'base64\'\fR or \fB\'hex\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Returns the enciphered contents, and can be called many times with new data as it is streamed\.
.
.SS "cipher\.final([output_encoding])"
Returns any remaining enciphered contents, with \fBoutput_encoding\fR being one of: \fB\'binary\'\fR, \fB\'base64\'\fR or \fB\'hex\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Note: \fBcipher\fR object can not be used after \fBfinal()\fR method been called\.
.
.SH "crypto\.createDecipher(algorithm, password)"
Creates and returns a decipher object, with the given algorithm and key\. This is the mirror of the \fIcreateCipher()\fR above\.
.
.SH "crypto\.createDecipheriv(algorithm, key, iv)"
Creates and returns a decipher object, with the given algorithm, key and iv\. This is the mirror of the \fIcreateCipheriv()\fR above\.
.
.SH "Class: Decipher"
Class for decrypting data\.
.
.P
Returned by \fBcrypto\.createDecipher\fR and \fBcrypto\.createDecipheriv\fR\.
.
.SS "decipher\.update(data, [input_encoding], [output_encoding])"
Updates the decipher with \fBdata\fR, which is encoded in \fB\'binary\'\fR, \fB\'base64\'\fR or \fB\'hex\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
The \fBoutput_decoding\fR specifies in what format to return the deciphered plaintext: \fB\'binary\'\fR, \fB\'ascii\'\fR or \fB\'utf8\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "decipher\.final([output_encoding])"
Returns any remaining plaintext which is deciphered, with \fBoutput_encoding\fR being one of: \fB\'binary\'\fR, \fB\'ascii\'\fR or \fB\'utf8\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Note: \fBdecipher\fR object can not be used after \fBfinal()\fR method been called\.
.
.SH "crypto\.createSign(algorithm)"
Creates and returns a signing object, with the given algorithm\. On recent OpenSSL releases, \fBopenssl list\-public\-key\-algorithms\fR will display the available signing algorithms\. Examples are \fB\'RSA\-SHA256\'\fR\.
.
.SH "Class: Signer"
Class for generating signatures\.
.
.P
Returned by \fBcrypto\.createSign\fR\.
.
.SS "signer\.update(data)"
Updates the signer object with data\. This can be called many times with new data as it is streamed\.
.
.SS "signer\.sign(private_key, [output_format])"
Calculates the signature on all the updated data passed through the signer\. \fBprivate_key\fR is a string containing the PEM encoded private key for signing\.
.
.P
Returns the signature in \fBoutput_format\fR which can be \fB\'binary\'\fR, \fB\'hex\'\fR or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Note: \fBsigner\fR object can not be used after \fBsign()\fR method been called\.
.
.SH "crypto\.createVerify(algorithm)"
Creates and returns a verification object, with the given algorithm\. This is the mirror of the signing object above\.
.
.SH "Class: Verify"
Class for verifying signatures\.
.
.P
Returned by \fBcrypto\.createVerify\fR\.
.
.SS "verifier\.update(data)"
Updates the verifier object with data\. This can be called many times with new data as it is streamed\.
.
.SS "verifier\.verify(object, signature, [signature_format])"
Verifies the signed data by using the \fBobject\fR and \fBsignature\fR\. \fBobject\fR is a string containing a PEM encoded object, which can be one of RSA public key, DSA public key, or X\.509 certificate\. \fBsignature\fR is the previously calculated signature for the data, in the \fBsignature_format\fR which can be \fB\'binary\'\fR, \fB\'hex\'\fR or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.P
Returns true or false depending on the validity of the signature for the data and public key\.
.
.P
Note: \fBverifier\fR object can not be used after \fBverify()\fR method been called\.
.
.SH "crypto\.createDiffieHellman(prime_length)"
Creates a Diffie\-Hellman key exchange object and generates a prime of the given bit length\. The generator used is \fB2\fR\.
.
.SH "crypto\.createDiffieHellman(prime, [encoding])"
Creates a Diffie\-Hellman key exchange object using the supplied prime\. The generator used is \fB2\fR\. Encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SH "Class: DiffieHellman"
The class for creating Diffie\-Hellman key exchanges\.
.
.P
Returned by \fBcrypto\.createDiffieHellman\fR\.
.
.SS "diffieHellman\.generateKeys([encoding])"
Generates private and public Diffie\-Hellman key values, and returns the public key in the specified encoding\. This key should be transferred to the other party\. Encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "diffieHellman\.computeSecret(other_public_key, [input_encoding], [output_encoding])"
Computes the shared secret using \fBother_public_key\fR as the other party\'s public key and returns the computed shared secret\. Supplied key is interpreted using specified \fBinput_encoding\fR, and secret is encoded using specified \fBoutput_encoding\fR\. Encodings can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. The input encoding defaults to \fB\'binary\'\fR\. If no output encoding is given, the input encoding is used as output encoding\.
.
.SS "diffieHellman\.getPrime([encoding])"
Returns the Diffie\-Hellman prime in the specified encoding, which can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "diffieHellman\.getGenerator([encoding])"
Returns the Diffie\-Hellman prime in the specified encoding, which can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "diffieHellman\.getPublicKey([encoding])"
Returns the Diffie\-Hellman public key in the specified encoding, which can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "diffieHellman\.getPrivateKey([encoding])"
Returns the Diffie\-Hellman private key in the specified encoding, which can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "diffieHellman\.setPublicKey(public_key, [encoding])"
Sets the Diffie\-Hellman public key\. Key encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SS "diffieHellman\.setPrivateKey(public_key, [encoding])"
Sets the Diffie\-Hellman private key\. Key encoding can be \fB\'binary\'\fR, \fB\'hex\'\fR, or \fB\'base64\'\fR\. Defaults to \fB\'binary\'\fR\.
.
.SH "crypto\.pbkdf2(password, salt, iterations, keylen, callback)"
Asynchronous PBKDF2 applies pseudorandom function HMAC\-SHA1 to derive a key of given length from the given password, salt and iterations\. The callback gets two arguments \fB(err, derivedKey)\fR\.
.
.SH "crypto\.randomBytes(size, [callback])"
Generates cryptographically strong pseudo\-random data\. Usage:
.
.IP "" 4
.
.nf

// async
crypto\.randomBytes(256, function(ex, buf) {
  if (ex) throw ex;
  console\.log(\'Have %d bytes of random data: %s\', buf\.length, buf);
});

// sync
try {
  var buf = crypto\.randomBytes(256);
  console\.log(\'Have %d bytes of random data: %s\', buf\.length, buf);
} catch (ex) {
  // handle error
}
.
.fi
.
.IP "" 0

