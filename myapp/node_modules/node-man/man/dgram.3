.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "DGRAM" "" "April 2012" "" ""
.
.nf

Stability: 3 \- Stable
.
.fi
.
.P
\fI!\-\- name=dgram \-\-\fR
.
.P
Datagram sockets are available through \fBrequire(\'dgram\')\fR\.
.
.SH "dgram\.createSocket(type, [callback])"
.
.IP "\(bu" 4
\fBtype\fR String\. Either \'udp4\' or \'udp6\'
.
.IP "\(bu" 4
\fBcallback\fR Function\. Attached as a listener to \fBmessage\fR events\. Optional
.
.IP "\(bu" 4
Returns: Socket object
.
.IP "" 0
.
.P
Creates a datagram Socket of the specified types\. Valid types are \fBudp4\fR and \fBudp6\fR\.
.
.P
Takes an optional callback which is added as a listener for \fBmessage\fR events\.
.
.P
Call \fBsocket\.bind\fR if you want to receive datagrams\. \fBsocket\.bind()\fR will bind to the "all interfaces" address on a random port (it does the right thing for both \fBudp4\fR and \fBudp6\fR sockets)\. You can then retrieve the address and port with \fBsocket\.address()\.address\fR and \fBsocket\.address()\.port\fR\.
.
.SH "Class: Socket"
The dgram Socket class encapsulates the datagram functionality\. It should be created via \fBdgram\.createSocket(type, [callback])\fR\.
.
.SS "Event: \'message\'"
.
.IP "\(bu" 4
\fBmsg\fR Buffer object\. The message
.
.IP "\(bu" 4
\fBrinfo\fR Object\. Remote address information
.
.IP "" 0
.
.P
Emitted when a new datagram is available on a socket\. \fBmsg\fR is a \fBBuffer\fR and \fBrinfo\fR is an object with the sender\'s address information and the number of bytes in the datagram\.
.
.SS "Event: \'listening\'"
Emitted when a socket starts listening for datagrams\. This happens as soon as UDP sockets are created\.
.
.SS "Event: \'close\'"
Emitted when a socket is closed with \fBclose()\fR\. No new \fBmessage\fR events will be emitted on this socket\.
.
.SS "Event: \'error\'"
.
.IP "\(bu" 4
\fBexception\fR Error object
.
.IP "" 0
.
.P
Emitted when an error occurs\.
.
.SS "dgram\.send(buf, offset, length, port, address, [callback])"
.
.IP "\(bu" 4
\fBbuf\fR Buffer object\. Message to be sent
.
.IP "\(bu" 4
\fBoffset\fR Integer\. Offset in the buffer where the message starts\.
.
.IP "\(bu" 4
\fBlength\fR Integer\. Number of bytes in the message\.
.
.IP "\(bu" 4
\fBport\fR Integer\. destination port
.
.IP "\(bu" 4
\fBaddress\fR String\. destination IP
.
.IP "\(bu" 4
\fBcallback\fR Function\. Callback when message is done being delivered\. Optional\.
.
.IP "" 0
.
.P
For UDP sockets, the destination port and IP address must be specified\. A string may be supplied for the \fBaddress\fR parameter, and it will be resolved with DNS\. An optional callback may be specified to detect any DNS errors and when \fBbuf\fR may be re\-used\. Note that DNS lookups will delay the time that a send takes place, at least until the next tick\. The only way to know for sure that a send has taken place is to use the callback\.
.
.P
If the socket has not been previously bound with a call to \fBbind\fR, it\'s assigned a random port number and bound to the "all interfaces" address (0\.0\.0\.0 for \fBudp4\fR sockets, ::0 for \fBudp6\fR sockets)\.
.
.P
Example of sending a UDP packet to a random port on \fBlocalhost\fR;
.
.IP "" 4
.
.nf

var dgram = require(\'dgram\');
var message = new Buffer("Some bytes");
var client = dgram\.createSocket("udp4");
client\.send(message, 0, message\.length, 41234, "localhost", function(err, bytes) {
  client\.close();
});
.
.fi
.
.IP "" 0
.
.P
\fBA Note about UDP datagram size\fR
.
.P
The maximum size of an \fBIPv4/v6\fR datagram depends on the \fBMTU\fR (\fIMaximum Transmission Unit\fR) and on the \fBPayload Length\fR field size\.
.
.IP "\(bu" 4
The \fBPayload Length\fR field is \fB16 bits\fR wide, which means that a normal payload cannot be larger than 64K octets including internet header and data (65,507 bytes = 65,535 − 8 bytes UDP header − 20 bytes IP header); this is generally true for loopback interfaces, but such long datagrams are impractical for most hosts and networks\.
.
.IP "\(bu" 4
The \fBMTU\fR is the largest size a given link layer technology can support for datagrams\. For any link, \fBIPv4\fR mandates a minimum \fBMTU\fR of \fB68\fR octets, while the recommended \fBMTU\fR for IPv4 is \fB576\fR (typically recommended as the \fBMTU\fR for dial\-up type applications), whether they arrive whole or in fragments\.
.
.IP
For \fBIPv6\fR, the minimum \fBMTU\fR is \fB1280\fR octets, however, the mandatory minimum fragment reassembly buffer size is \fB1500\fR octets\. The value of \fB68\fR octets is very small, since most current link layer technologies have a minimum \fBMTU\fR of \fB1500\fR (like Ethernet)\.
.
.IP "" 0
.
.P
Note that it\'s impossible to know in advance the MTU of each link through which a packet might travel, and that generally sending a datagram greater than the (receiver) \fBMTU\fR won\'t work (the packet gets silently dropped, without informing the source that the data did not reach its intended recipient)\.
.
.SS "dgram\.bind(port, [address])"
.
.IP "\(bu" 4
\fBport\fR Integer
.
.IP "\(bu" 4
\fBaddress\fR String, Optional
.
.IP "" 0
.
.P
For UDP sockets, listen for datagrams on a named \fBport\fR and optional \fBaddress\fR\. If \fBaddress\fR is not specified, the OS will try to listen on all addresses\.
.
.P
Example of a UDP server listening on port 41234:
.
.IP "" 4
.
.nf

var dgram = require("dgram");

var server = dgram\.createSocket("udp4");

server\.on("message", function (msg, rinfo) {
  console\.log("server got: " + msg + " from " +
    rinfo\.address + ":" + rinfo\.port);
});

server\.on("listening", function () {
  var address = server\.address();
  console\.log("server listening " +
      address\.address + ":" + address\.port);
});

server\.bind(41234);
// server listening 0\.0\.0\.0:41234
.
.fi
.
.IP "" 0
.
.SS "dgram\.close()"
Close the underlying socket and stop listening for data on it\.
.
.SS "dgram\.address()"
Returns an object containing the address information for a socket\. For UDP sockets, this object will contain \fBaddress\fR and \fBport\fR\.
.
.SS "dgram\.setBroadcast(flag)"
.
.IP "\(bu" 4
\fBflag\fR Boolean
.
.IP "" 0
.
.P
Sets or clears the \fBSO_BROADCAST\fR socket option\. When this option is set, UDP packets may be sent to a local interface\'s broadcast address\.
.
.SS "dgram\.setTTL(ttl)"
.
.IP "\(bu" 4
\fBttl\fR Integer
.
.IP "" 0
.
.P
Sets the \fBIP_TTL\fR socket option\. TTL stands for "Time to Live," but in this context it specifies the number of IP hops that a packet is allowed to go through\. Each router or gateway that forwards a packet decrements the TTL\. If the TTL is decremented to 0 by a router, it will not be forwarded\. Changing TTL values is typically done for network probes or when multicasting\.
.
.P
The argument to \fBsetTTL()\fR is a number of hops between 1 and 255\. The default on most systems is 64\.
.
.SS "dgram\.setMulticastTTL(ttl)"
.
.IP "\(bu" 4
\fBttl\fR Integer
.
.IP "" 0
.
.P
Sets the \fBIP_MULTICAST_TTL\fR socket option\. TTL stands for "Time to Live," but in this context it specifies the number of IP hops that a packet is allowed to go through, specifically for multicast traffic\. Each router or gateway that forwards a packet decrements the TTL\. If the TTL is decremented to 0 by a router, it will not be forwarded\.
.
.P
The argument to \fBsetMulticastTTL()\fR is a number of hops between 0 and 255\. The default on most systems is 64\.
.
.SS "dgram\.setMulticastLoopback(flag)"
.
.IP "\(bu" 4
\fBflag\fR Boolean
.
.IP "" 0
.
.P
Sets or clears the \fBIP_MULTICAST_LOOP\fR socket option\. When this option is set, multicast packets will also be received on the local interface\.
.
.SS "dgram\.addMembership(multicastAddress, [multicastInterface])"
.
.IP "\(bu" 4
\fBmulticastAddress\fR String
.
.IP "\(bu" 4
\fBmulticastInterface\fR String, Optional
.
.IP "" 0
.
.P
Tells the kernel to join a multicast group with \fBIP_ADD_MEMBERSHIP\fR socket option\.
.
.P
If \fBmulticastInterface\fR is not specified, the OS will try to add membership to all valid interfaces\.
.
.SS "dgram\.dropMembership(multicastAddress, [multicastInterface])"
.
.IP "\(bu" 4
\fBmulticastAddress\fR String
.
.IP "\(bu" 4
\fBmulticastInterface\fR String, Optional
.
.IP "" 0
.
.P
Opposite of \fBaddMembership\fR \- tells the kernel to leave a multicast group with \fBIP_DROP_MEMBERSHIP\fR socket option\. This is automatically called by the kernel when the socket is closed or process terminates, so most apps will never need to call this\.
.
.P
If \fBmulticastInterface\fR is not specified, the OS will try to drop membership to all valid interfaces\.
