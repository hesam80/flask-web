.\" generated with Ronn/v0.7.3
.\" http://github.com/rtomayko/ronn/tree/0.7.3
.
.TH "TLS" "" "April 2012" "" ""
.
.nf

Stability: 3 \- Stable
.
.fi
.
.P
Use \fBrequire(\'tls\')\fR to access this module\.
.
.P
The \fBtls\fR module uses OpenSSL to provide Transport Layer Security and/or Secure Socket Layer: encrypted stream communication\.
.
.P
TLS/SSL is a public/private key infrastructure\. Each client and each server must have a private key\. A private key is created like this
.
.IP "" 4
.
.nf

openssl genrsa \-out ryans\-key\.pem 1024
.
.fi
.
.IP "" 0
.
.P
All severs and some clients need to have a certificate\. Certificates are public keys signed by a Certificate Authority or self\-signed\. The first step to getting a certificate is to create a "Certificate Signing Request" (CSR) file\. This is done with:
.
.IP "" 4
.
.nf

openssl req \-new \-key ryans\-key\.pem \-out ryans\-csr\.pem
.
.fi
.
.IP "" 0
.
.P
To create a self\-signed certificate with the CSR, do this:
.
.IP "" 4
.
.nf

openssl x509 \-req \-in ryans\-csr\.pem \-signkey ryans\-key\.pem \-out ryans\-cert\.pem
.
.fi
.
.IP "" 0
.
.P
Alternatively you can send the CSR to a Certificate Authority for signing\.
.
.P
(TODO: docs on creating a CA, for now interested users should just look at \fBtest/fixtures/keys/Makefile\fR in the Node source code)
.
.SH "Client\-initiated renegotiation attack mitigation"
\fI!\-\- type=misc \-\-\fR
.
.P
The TLS protocol lets the client renegotiate certain aspects of the TLS session\. Unfortunately, session renegotiation requires a disproportional amount of server\-side resources, which makes it a potential vector for denial\-of\-service attacks\.
.
.P
To mitigate this, renegotiations are limited to three times every 10 minutes\. An error is emitted on the \fICleartextStream\fR instance when the threshold is exceeded\. The limits are configurable:
.
.IP "\(bu" 4
\fBtls\.CLIENT_RENEG_LIMIT\fR: renegotiation limit, default is 3\.
.
.IP "\(bu" 4
\fBtls\.CLIENT_RENEG_WINDOW\fR: renegotiation window in seconds, default is
.
.IP "" 4
.
.nf

                       10 minutes\.
.
.fi
.
.IP "" 0

.
.IP "" 0
.
.P
Don\'t change the defaults unless you know what you are doing\.
.
.P
To test your server, connect to it with \fBopenssl s_client \-connect address:port\fR and tap \fBR<CR>\fR (that\'s the letter \fBR\fR followed by a carriage return) a few times\.
.
.SH "NPN and SNI"
\fI!\-\- type=misc \-\-\fR
.
.P
NPN (Next Protocol Negotiation) and SNI (Server Name Indication) are TLS handshake extensions allowing you:
.
.IP "\(bu" 4
NPN \- to use one TLS server for multiple protocols (HTTP, SPDY)
.
.IP "\(bu" 4
SNI \- to use one TLS server for multiple hostnames with different SSL certificates\.
.
.IP "" 0
.
.SH "tls\.createServer(options, [secureConnectionListener])"
Creates a new \fItls\.Server\fR\. The \fBconnectionListener\fR argument is automatically set as a listener for the \fIsecureConnection\fR event\. The \fBoptions\fR object has these possibilities:
.
.IP "\(bu" 4
\fBkey\fR: A string or \fBBuffer\fR containing the private key of the server in PEM format\. (Required)
.
.IP "\(bu" 4
\fBpassphrase\fR: A string of passphrase for the private key\.
.
.IP "\(bu" 4
\fBcert\fR: A string or \fBBuffer\fR containing the certificate key of the server in PEM format\. (Required)
.
.IP "\(bu" 4
\fBca\fR: An array of strings or \fBBuffer\fRs of trusted certificates\. If this is omitted several well known "root" CAs will be used, like VeriSign\. These are used to authorize connections\.
.
.IP "\(bu" 4
\fBciphers\fR: A string describing the ciphers to use or exclude\. Consult \fIhttp://www\.openssl\.org/docs/apps/ciphers\.html#CIPHER_LIST_FORMAT\fR for details on the format\.
.
.IP "\(bu" 4
\fBrequestCert\fR: If \fBtrue\fR the server will request a certificate from clients that connect and attempt to verify that certificate\. Default: \fBfalse\fR\.
.
.IP "\(bu" 4
\fBrejectUnauthorized\fR: If \fBtrue\fR the server will reject any connection which is not authorized with the list of supplied CAs\. This option only has an effect if \fBrequestCert\fR is \fBtrue\fR\. Default: \fBfalse\fR\.
.
.IP "\(bu" 4
\fBNPNProtocols\fR: An array or \fBBuffer\fR of possible NPN protocols\. (Protocols should be ordered by their priority)\.
.
.IP "\(bu" 4
\fBSNICallback\fR: A function that will be called if client supports SNI TLS extension\. Only one argument will be passed to it: \fBservername\fR\. And \fBSNICallback\fR should return SecureContext instance\. (You can use \fBcrypto\.createCredentials(\.\.\.)\.context\fR to get proper SecureContext)\. If \fBSNICallback\fR wasn\'t provided \- default callback with high\-level API will be used (see below)\.
.
.IP "\(bu" 4
\fBsessionIdContext\fR: A string containing a opaque identifier for session resumption\. If \fBrequestCert\fR is \fBtrue\fR, the default is MD5 hash value generated from command\-line\. Otherwise, the default is not provided\.
.
.IP "" 0
.
.P
Here is a simple example echo server:
.
.IP "" 4
.
.nf

var tls = require(\'tls\');
var fs = require(\'fs\');

var options = {
  key: fs\.readFileSync(\'server\-key\.pem\'),
  cert: fs\.readFileSync(\'server\-cert\.pem\'),

  // This is necessary only if using the client certificate authentication\.
  requestCert: true,

  // This is necessary only if the client uses the self\-signed certificate\.
  ca: [ fs\.readFileSync(\'client\-cert\.pem\') ]
};

var server = tls\.createServer(options, function(cleartextStream) {
  console\.log(\'server connected\',
              cleartextStream\.authorized ? \'authorized\' : \'unauthorized\');
  cleartextStream\.write("welcome!\en");
  cleartextStream\.setEncoding(\'utf8\');
  cleartextStream\.pipe(cleartextStream);
});
server\.listen(8000, function() {
  console\.log(\'server bound\');
});
.
.fi
.
.IP "" 0
.
.P
You can test this server by connecting to it with \fBopenssl s_client\fR:
.
.IP "" 4
.
.nf

openssl s_client \-connect 127\.0\.0\.1:8000
.
.fi
.
.IP "" 0
.
.SH "tls\.connect(port, [host], [options], [secureConnectListener])"
Creates a new client connection to the given \fBport\fR and \fBhost\fR\. (If \fBhost\fR defaults to \fBlocalhost\fR\.) \fBoptions\fR should be an object which specifies
.
.IP "\(bu" 4
\fBkey\fR: A string or \fBBuffer\fR containing the private key of the client in PEM format\.
.
.IP "\(bu" 4
\fBpassphrase\fR: A string of passphrase for the private key\.
.
.IP "\(bu" 4
\fBcert\fR: A string or \fBBuffer\fR containing the certificate key of the client in PEM format\.
.
.IP "\(bu" 4
\fBca\fR: An array of strings or \fBBuffer\fRs of trusted certificates\. If this is omitted several well known "root" CAs will be used, like VeriSign\. These are used to authorize connections\.
.
.IP "\(bu" 4
\fBNPNProtocols\fR: An array of string or \fBBuffer\fR containing supported NPN protocols\. \fBBuffer\fR should have following format: \fB0x05hello0x05world\fR, where first byte is next protocol name\'s length\. (Passing array should usually be much simpler: \fB[\'hello\', \'world\']\fR\.)
.
.IP "\(bu" 4
\fBservername\fR: Servername for SNI (Server Name Indication) TLS extension\.
.
.IP "\(bu" 4
\fBsocket\fR: Establish secure connection on a given socket rather than creating a new socket\. If this option is specified, \fBhost\fR and \fBport\fR are ignored\. This is intended FOR INTERNAL USE ONLY\. As with all undocumented APIs in Node, they should not be used\.
.
.IP "" 0
.
.P
The \fBsecureConnectListener\fR parameter will be added as a listener for the \fI\'secureConnect\'\fR event\.
.
.P
\fBtls\.connect()\fR returns a \fICleartextStream\fR object\.
.
.P
Here is an example of a client of echo server as described previously:
.
.IP "" 4
.
.nf

var tls = require(\'tls\');
var fs = require(\'fs\');

var options = {
  // These are necessary only if using the client certificate authentication
  key: fs\.readFileSync(\'client\-key\.pem\'),
  cert: fs\.readFileSync(\'client\-cert\.pem\'),

  // This is necessary only if the server uses the self\-signed certificate
  ca: [ fs\.readFileSync(\'server\-cert\.pem\') ]
};

var cleartextStream = tls\.connect(8000, options, function() {
  console\.log(\'client connected\',
              cleartextStream\.authorized ? \'authorized\' : \'unauthorized\');
  process\.stdin\.pipe(cleartextStream);
  process\.stdin\.resume();
});
cleartextStream\.setEncoding(\'utf8\');
cleartextStream\.on(\'data\', function(data) {
  console\.log(data);
});
cleartextStream\.on(\'end\', function() {
  server\.close();
});
.
.fi
.
.IP "" 0
.
.SH "tls\.createSecurePair([credentials], [isServer], [requestCert], [rejectUnauthorized])"
Creates a new secure pair object with two streams, one of which reads/writes encrypted data, and one reads/writes cleartext data\. Generally the encrypted one is piped to/from an incoming encrypted data stream, and the cleartext one is used as a replacement for the initial encrypted stream\.
.
.IP "\(bu" 4
\fBcredentials\fR: A credentials object from crypto\.createCredentials( \.\.\. )
.
.IP "\(bu" 4
\fBisServer\fR: A boolean indicating whether this tls connection should be opened as a server or a client\.
.
.IP "\(bu" 4
\fBrequestCert\fR: A boolean indicating whether a server should request a certificate from a connecting client\. Only applies to server connections\.
.
.IP "\(bu" 4
\fBrejectUnauthorized\fR: A boolean indicating whether a server should automatically reject clients with invalid certificates\. Only applies to servers with \fBrequestCert\fR enabled\.
.
.IP "" 0
.
.P
\fBtls\.createSecurePair()\fR returns a SecurePair object with \fIcleartext\fR and \fBencrypted\fR stream properties\.
.
.SH "Class: SecurePair"
Returned by tls\.createSecurePair\.
.
.SS "Event: \'secure\'"
The event is emitted from the SecurePair once the pair has successfully established a secure connection\.
.
.P
Similarly to the checking for the server \'secureConnection\' event, pair\.cleartext\.authorized should be checked to confirm whether the certificate used properly authorized\.
.
.SH "Class: tls\.Server"
This class is a subclass of \fBnet\.Server\fR and has the same methods on it\. Instead of accepting just raw TCP connections, this accepts encrypted connections using TLS or SSL\.
.
.SS "Event: \'secureConnection\'"
\fBfunction (cleartextStream) {}\fR
.
.P
This event is emitted after a new connection has been successfully handshaked\. The argument is a instance of \fICleartextStream\fR\. It has all the common stream methods and events\.
.
.P
\fBcleartextStream\.authorized\fR is a boolean value which indicates if the client has verified by one of the supplied certificate authorities for the server\. If \fBcleartextStream\.authorized\fR is false, then \fBcleartextStream\.authorizationError\fR is set to describe how authorization failed\. Implied but worth mentioning: depending on the settings of the TLS server, you unauthorized connections may be accepted\. \fBcleartextStream\.npnProtocol\fR is a string containing selected NPN protocol\. \fBcleartextStream\.servername\fR is a string containing servername requested with SNI\.
.
.SS "Event: \'clientError\'"
\fBfunction (exception) { }\fR
.
.P
When a client connection emits an \'error\' event before secure connection is established \- it will be forwarded here\.
.
.SS "server\.listen(port, [host], [callback])"
Begin accepting connections on the specified \fBport\fR and \fBhost\fR\. If the \fBhost\fR is omitted, the server will accept connections directed to any IPv4 address (\fBINADDR_ANY\fR)\.
.
.P
This function is asynchronous\. The last parameter \fBcallback\fR will be called when the server has been bound\.
.
.P
See \fBnet\.Server\fR for more information\.
.
.SS "server\.close()"
Stops the server from accepting new connections\. This function is asynchronous, the server is finally closed when the server emits a \fB\'close\'\fR event\.
.
.SS "server\.address()"
Returns the bound address and port of the server as reported by the operating system\. See net\.Server\.address() \fInet\.html#server\.address\fR for more information\.
.
.SS "server\.addContext(hostname, credentials)"
Add secure context that will be used if client request\'s SNI hostname is matching passed \fBhostname\fR (wildcards can be used)\. \fBcredentials\fR can contain \fBkey\fR, \fBcert\fR and \fBca\fR\.
.
.SS "server\.maxConnections"
Set this property to reject connections when the server\'s connection count gets high\.
.
.SS "server\.connections"
The number of concurrent connections on the server\.
.
.SH "Class: tls\.CleartextStream"
This is a stream on top of the \fIEncrypted\fR stream that makes it possible to read/write an encrypted data as a cleartext data\.
.
.P
This instance implements a duplex Stream \fIstream\.html\fR interfaces\. It has all the common stream methods and events\.
.
.P
A ClearTextStream is the \fBclear\fR member of a SecurePair object\.
.
.SS "Event: \'secureConnect\'"
This event is emitted after a new connection has been successfully handshaked\. The listener will be called no matter if the server\'s certificate was authorized or not\. It is up to the user to test \fBcleartextStream\.authorized\fR to see if the server certificate was signed by one of the specified CAs\. If \fBcleartextStream\.authorized === false\fR then the error can be found in \fBcleartextStream\.authorizationError\fR\. Also if NPN was used \- you can check \fBcleartextStream\.npnProtocol\fR for negotiated protocol\.
.
.SS "cleartextStream\.authorized"
A boolean that is \fBtrue\fR if the peer certificate was signed by one of the specified CAs, otherwise \fBfalse\fR
.
.SS "cleartextStream\.authorizationError"
The reason why the peer\'s certificate has not been verified\. This property becomes available only when \fBcleartextStream\.authorized === false\fR\.
.
.SS "cleartextStream\.getPeerCertificate()"
Returns an object representing the peer\'s certificate\. The returned object has some properties corresponding to the field of the certificate\.
.
.P
Example:
.
.IP "" 4
.
.nf

{ subject:
   { C: \'UK\',
     ST: \'Acknack Ltd\',
     L: \'Rhys Jones\',
     O: \'node\.js\',
     OU: \'Test TLS Certificate\',
     CN: \'localhost\' },
  issuer:
   { C: \'UK\',
     ST: \'Acknack Ltd\',
     L: \'Rhys Jones\',
     O: \'node\.js\',
     OU: \'Test TLS Certificate\',
     CN: \'localhost\' },
  valid_from: \'Nov 11 09:52:22 2009 GMT\',
  valid_to: \'Nov  6 09:52:22 2029 GMT\',
  fingerprint: \'2A:7A:C2:DD:E5:F9:CC:53:72:35:99:7A:02:5A:71:38:52:EC:8A:DF\' }
.
.fi
.
.IP "" 0
.
.P
If the peer does not provide a certificate, it returns \fBnull\fR or an empty object\.
.
.SS "cleartextStream\.address()"
Returns the bound address and port of the underlying socket as reported by the operating system\. Returns an object with two properties, e\.g\. \fB{"address":"192\.168\.57\.1", "port":62053}\fR
.
.SS "cleartextStream\.remoteAddress"
The string representation of the remote IP address\. For example, \fB\'74\.125\.127\.100\'\fR or \fB\'2001:4860:a005::68\'\fR\.
.
.SS "cleartextStream\.remotePort"
The numeric representation of the remote port\. For example, \fB443\fR\.
